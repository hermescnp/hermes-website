{
  "version": 3,
  "sources": ["../../@react-three/drei/materials/WireframeMaterial.js", "../../@react-three/drei/core/shaderMaterial.js"],
  "sourcesContent": ["import * as THREE from 'three';\nimport * as React from 'react';\nimport { shaderMaterial } from '../core/shaderMaterial.js';\n\nconst WireframeMaterialShaders = {\n  uniforms: {\n    strokeOpacity: 1,\n    fillOpacity: 0.25,\n    fillMix: 0,\n    thickness: 0.05,\n    colorBackfaces: false,\n    dashInvert: true,\n    dash: false,\n    dashRepeats: 4,\n    dashLength: 0.5,\n    squeeze: false,\n    squeezeMin: 0.2,\n    squeezeMax: 1,\n    stroke: new THREE.Color('#ff0000'),\n    backfaceStroke: new THREE.Color('#0000ff'),\n    fill: new THREE.Color('#00ff00')\n  },\n  vertex:\n  /* glsl */\n  `\n\t  attribute vec3 barycentric;\n\t\n\t\tvarying vec3 v_edges_Barycentric;\n\t\tvarying vec3 v_edges_Position;\n\n\t\tvoid initWireframe() {\n\t\t\tv_edges_Barycentric = barycentric;\n\t\t\tv_edges_Position = position.xyz;\n\t\t}\n\t  `,\n  fragment:\n  /* glsl */\n  `\n\t\t#ifndef PI\n\t  \t#define PI 3.1415926535897932384626433832795\n\t\t#endif\n  \n\t  varying vec3 v_edges_Barycentric;\n\t  varying vec3 v_edges_Position;\n  \n\t  uniform float strokeOpacity;\n\t  uniform float fillOpacity;\n\t  uniform float fillMix;\n\t  uniform float thickness;\n\t  uniform bool colorBackfaces;\n  \n\t  // Dash\n\t  uniform bool dashInvert;\n\t  uniform bool dash;\n\t  uniform bool dashOnly;\n\t  uniform float dashRepeats;\n\t  uniform float dashLength;\n  \n\t  // Squeeze\n\t  uniform bool squeeze;\n\t  uniform float squeezeMin;\n\t  uniform float squeezeMax;\n  \n\t  // Colors\n\t  uniform vec3 stroke;\n\t  uniform vec3 backfaceStroke;\n\t  uniform vec3 fill;\n  \n\t  // This is like\n\t  float wireframe_aastep(float threshold, float dist) {\n\t\t  float afwidth = fwidth(dist) * 0.5;\n\t\t  return smoothstep(threshold - afwidth, threshold + afwidth, dist);\n\t  }\n  \n\t  float wireframe_map(float value, float min1, float max1, float min2, float max2) {\n\t\t  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n\t  }\n  \n\t  float getWireframe() {\n\t\t\tvec3 barycentric = v_edges_Barycentric;\n\t\t\n\t\t\t// Distance from center of each triangle to its edges.\n\t\t\tfloat d = min(min(barycentric.x, barycentric.y), barycentric.z);\n\n\t\t\t// for dashed rendering, we can use this to get the 0 .. 1 value of the line length\n\t\t\tfloat positionAlong = max(barycentric.x, barycentric.y);\n\t\t\tif (barycentric.y < barycentric.x && barycentric.y < barycentric.z) {\n\t\t\t\tpositionAlong = 1.0 - positionAlong;\n\t\t\t}\n\n\t\t\t// the thickness of the stroke\n\t\t\tfloat computedThickness = wireframe_map(thickness, 0.0, 1.0, 0.0, 0.34);\n\n\t\t\t// if we want to shrink the thickness toward the center of the line segment\n\t\t\tif (squeeze) {\n\t\t\t\tcomputedThickness *= mix(squeezeMin, squeezeMax, (1.0 - sin(positionAlong * PI)));\n\t\t\t}\n\n\t\t\t// Create dash pattern\n\t\t\tif (dash) {\n\t\t\t\t// here we offset the stroke position depending on whether it\n\t\t\t\t// should overlap or not\n\t\t\t\tfloat offset = 1.0 / dashRepeats * dashLength / 2.0;\n\t\t\t\tif (!dashInvert) {\n\t\t\t\t\toffset += 1.0 / dashRepeats / 2.0;\n\t\t\t\t}\n\n\t\t\t\t// if we should animate the dash or not\n\t\t\t\t// if (dashAnimate) {\n\t\t\t\t// \toffset += time * 0.22;\n\t\t\t\t// }\n\n\t\t\t\t// create the repeating dash pattern\n\t\t\t\tfloat pattern = fract((positionAlong + offset) * dashRepeats);\n\t\t\t\tcomputedThickness *= 1.0 - wireframe_aastep(dashLength, pattern);\n\t\t\t}\n\n\t\t\t// compute the anti-aliased stroke edge  \n\t\t\tfloat edge = 1.0 - wireframe_aastep(computedThickness, d);\n\n\t\t\treturn edge;\n\t  }\n\t  `\n};\nconst WireframeMaterial = shaderMaterial(WireframeMaterialShaders.uniforms, WireframeMaterialShaders.vertex +\n/* glsl */\n`\n  \tvoid main() {\n\t\tinitWireframe();\n\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\t}\n  `, WireframeMaterialShaders.fragment +\n/* glsl */\n`\n  void main () {\n\t\t// Compute color\n\n\t\tfloat edge = getWireframe();\n\t\tvec4 colorStroke = vec4(stroke, edge);\n\n\t\t#ifdef FLIP_SIDED\n\t\t\tcolorStroke.rgb = backfaceStroke;\n\t\t#endif\n    \n\t\tvec4 colorFill = vec4(fill, fillOpacity);\n\t\tvec4 outColor = mix(colorFill, colorStroke, edge * strokeOpacity);\n\n\t\tgl_FragColor = outColor;\n\t}\n  `);\nfunction setWireframeOverride(material, uniforms) {\n  material.onBeforeCompile = shader => {\n    shader.uniforms = { ...shader.uniforms,\n      ...uniforms\n    };\n    shader.vertexShader = shader.vertexShader.replace('void main() {', `\n\t\t  ${WireframeMaterialShaders.vertex}\n\t\t  void main() {\n\t\t\tinitWireframe();\n\t\t`);\n    shader.fragmentShader = shader.fragmentShader.replace('void main() {', `\n\t\t  ${WireframeMaterialShaders.fragment}\n\t\t  void main() {\n\t\t`);\n    shader.fragmentShader = shader.fragmentShader.replace('#include <color_fragment>',\n    /* glsl */\n    `\n\t\t  #include <color_fragment>\n\t\t\t  float edge = getWireframe();\n\t\t  vec4 colorStroke = vec4(stroke, edge);\n\t\t  #ifdef FLIP_SIDED\n\t\t\tcolorStroke.rgb = backfaceStroke;\n\t\t  #endif\n\t\t  vec4 colorFill = vec4(mix(diffuseColor.rgb, fill, fillMix), mix(diffuseColor.a, fillOpacity, fillMix));\n\t\t  vec4 outColor = mix(colorFill, colorStroke, edge * strokeOpacity);\n\n\t\t  diffuseColor.rgb = outColor.rgb;\n\t\t  diffuseColor.a *= outColor.a;\n\t\t`);\n  };\n\n  material.side = THREE.DoubleSide;\n  material.transparent = true;\n}\nfunction useWireframeUniforms(uniforms, props) {\n  React.useEffect(() => {\n    var _props$fillOpacity;\n\n    return void (uniforms.fillOpacity.value = (_props$fillOpacity = props.fillOpacity) !== null && _props$fillOpacity !== void 0 ? _props$fillOpacity : uniforms.fillOpacity.value);\n  }, [props.fillOpacity]);\n  React.useEffect(() => {\n    var _props$fillMix;\n\n    return void (uniforms.fillMix.value = (_props$fillMix = props.fillMix) !== null && _props$fillMix !== void 0 ? _props$fillMix : uniforms.fillMix.value);\n  }, [props.fillMix]);\n  React.useEffect(() => {\n    var _props$strokeOpacity;\n\n    return void (uniforms.strokeOpacity.value = (_props$strokeOpacity = props.strokeOpacity) !== null && _props$strokeOpacity !== void 0 ? _props$strokeOpacity : uniforms.strokeOpacity.value);\n  }, [props.strokeOpacity]);\n  React.useEffect(() => {\n    var _props$thickness;\n\n    return void (uniforms.thickness.value = (_props$thickness = props.thickness) !== null && _props$thickness !== void 0 ? _props$thickness : uniforms.thickness.value);\n  }, [props.thickness]);\n  React.useEffect(() => void (uniforms.colorBackfaces.value = !!props.colorBackfaces), [props.colorBackfaces]);\n  React.useEffect(() => void (uniforms.dash.value = !!props.dash), [props.dash]);\n  React.useEffect(() => void (uniforms.dashInvert.value = !!props.dashInvert), [props.dashInvert]);\n  React.useEffect(() => {\n    var _props$dashRepeats;\n\n    return void (uniforms.dashRepeats.value = (_props$dashRepeats = props.dashRepeats) !== null && _props$dashRepeats !== void 0 ? _props$dashRepeats : uniforms.dashRepeats.value);\n  }, [props.dashRepeats]);\n  React.useEffect(() => {\n    var _props$dashLength;\n\n    return void (uniforms.dashLength.value = (_props$dashLength = props.dashLength) !== null && _props$dashLength !== void 0 ? _props$dashLength : uniforms.dashLength.value);\n  }, [props.dashLength]);\n  React.useEffect(() => void (uniforms.squeeze.value = !!props.squeeze), [props.squeeze]);\n  React.useEffect(() => {\n    var _props$squeezeMin;\n\n    return void (uniforms.squeezeMin.value = (_props$squeezeMin = props.squeezeMin) !== null && _props$squeezeMin !== void 0 ? _props$squeezeMin : uniforms.squeezeMin.value);\n  }, [props.squeezeMin]);\n  React.useEffect(() => {\n    var _props$squeezeMax;\n\n    return void (uniforms.squeezeMax.value = (_props$squeezeMax = props.squeezeMax) !== null && _props$squeezeMax !== void 0 ? _props$squeezeMax : uniforms.squeezeMax.value);\n  }, [props.squeezeMax]);\n  React.useEffect(() => void (uniforms.stroke.value = props.stroke ? new THREE.Color(props.stroke) : uniforms.stroke.value), [props.stroke]);\n  React.useEffect(() => void (uniforms.fill.value = props.fill ? new THREE.Color(props.fill) : uniforms.fill.value), [props.fill]);\n  React.useEffect(() => void (uniforms.backfaceStroke.value = props.backfaceStroke ? new THREE.Color(props.backfaceStroke) : uniforms.backfaceStroke.value), [props.backfaceStroke]);\n}\n\nexport { WireframeMaterial, WireframeMaterialShaders, setWireframeOverride, useWireframeUniforms };\n", "import * as THREE from 'three';\n\nfunction shaderMaterial(uniforms, vertexShader, fragmentShader, onInit) {\n  const material = class material extends THREE.ShaderMaterial {\n    constructor(parameters = {}) {\n      const entries = Object.entries(uniforms); // Create unforms and shaders\n\n      super({\n        uniforms: entries.reduce((acc, [name, value]) => {\n          const uniform = THREE.UniformsUtils.clone({\n            [name]: {\n              value\n            }\n          });\n          return { ...acc,\n            ...uniform\n          };\n        }, {}),\n        vertexShader,\n        fragmentShader\n      }); // Create getter/setters\n\n      this.key = '';\n      entries.forEach(([name]) => Object.defineProperty(this, name, {\n        get: () => this.uniforms[name].value,\n        set: v => this.uniforms[name].value = v\n      })); // Assign parameters, this might include uniforms\n\n      Object.assign(this, parameters); // Call onInit\n\n      if (onInit) onInit(this);\n    }\n\n  };\n  material.key = THREE.MathUtils.generateUUID();\n  return material;\n}\n\nexport { shaderMaterial };\n"],
  "mappings": "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",
  "names": []
}
